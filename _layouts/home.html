---
layout: default
title: Home
---

{%- comment -%}
Fixed full-viewport shader background (behind header + content),
then a spacer to keep the first fold as the hero.
{%- endcomment -%}
{% include shader-hero.html %}

<div class="shader-spacer" aria-hidden="false"></div>

<section class="link-circles" aria-label="Profile links">
  <!-- Google Scholar -->
  <a class="fancy"
     href="{{ site.scholar_url | default: 'https://scholar.google.com/citations?user=HSduCL0AAAAJ' }}"
     target="_blank" rel="noopener noreferrer">
    <span class="top-key"></span>
    <span class="logo" aria-hidden="true">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path fill="currentColor"
          d="M6 4h9a3 3 0 0 1 3 3v12.5a.5.5 0 0 1-.8.4L15 18H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm0 2v10h9.6l1.4.9V7a1 1 0 0 0-1-1Z"/>
      </svg>
    </span>
    <span class="text">Google Scholar</span>
    <span class="bottom-key-1"></span>
    <span class="bottom-key-2"></span>
  </a>

  <!-- ORCID -->
  <a class="fancy"
     href="https://orcid.org/{{ site.orcid_id | default: 'https://orcid.org/0000-0002-4780-8993' }}"
     target="_blank" rel="noopener noreferrer">
    <span class="top-key"></span>
    <span class="logo" aria-hidden="true">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path fill="currentColor"
          d="M12 2a10 10 0 1 0 .001 20.001A10 10 0 0 0 12 2Zm-1.9 6.1v7.8h-1.3V8.1h1.3Zm6.4 3.9a3.6 3.6 0 0 1-3.6 3.7h-1.6V8.1h1.6a3.6 3.6 0 0 1 3.6 3.9Zm-1.3 0a2.3 2.3 0 0 0-2.3-2.6h-.3v5.1h.3a2.3 2.3 0 0 0 2.3-2.5Z"/>
      </svg>
    </span>
    <span class="text">ORCID</span>
    <span class="bottom-key-1"></span>
    <span class="bottom-key-2"></span>
  </a>

  <!-- OSF -->
  <a class="fancy"
     href="{{ site.osf_url | default: 'https://osf.io/92fa4/' }}"
     target="_blank" rel="noopener noreferrer">
    <span class="top-key"></span>
    <span class="logo" aria-hidden="true">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path fill="currentColor"
          d="M12 2 3 7v10l9 5 9-5V7l-9-5Zm0 2.2 6.6 3.7L12 11.3 5.4 7.9 12 4.2ZM5 9.6l6 3.3v6.9L5 16.5V9.6Zm8 10.2v-6.9l6-3.3v6.9L13 19.8Z"/>
      </svg>
    </span>
    <span class="text">OSF</span>
    <span class="bottom-key-1"></span>
    <span class="bottom-key-2"></span>
  </a>

  <!-- LinkedIn -->
  <a class="fancy"
     href="{{ site.linkedin_url | default: 'https://www.linkedin.com/in/julian-ockelmann-977208170/' }}"
     target="_blank" rel="noopener noreferrer">
    <span class="top-key"></span>
    <span class="logo" aria-hidden="true">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path fill="currentColor"
          d="M6.94 8.5H4.5V20h2.44V8.5ZM5.72 7.3a1.4 1.4 0 1 0 0-2.8 1.4 1.4 0 0 0 0 2.8ZM20 20h-2.43v-5.9c0-1.77-.69-2.76-2.13-2.76-1.56 0-2.37 1.05-2.37 2.76V20H10.6V8.5h2.32v1.57h.03c.41-.77 1.63-1.87 3.36-1.87 2.22 0 3.7 1.44 3.7 4.42V20Z"/>
      </svg>
    </span>
    <span class="text">LinkedIn</span>
    <span class="bottom-key-1"></span>
    <span class="bottom-key-2"></span>
  </a>
</section>

<script>
(function () {
  // Prevent double-boot if another script also runs
  if (window.__homeShaderBooted) return;
  window.__homeShaderBooted = true;

  // Only run if the banner container exists
  var container = document.getElementById('shader-banner');
  var canvas    = document.getElementById('webgl-canvas');
  if (!container || !canvas || typeof THREE === 'undefined') return;

  var renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
  // Cap DPR to keep buffer sizes sane on 4k/retina
  var dpr = Math.min(window.devicePixelRatio || 1, 2);
  renderer.setPixelRatio(dpr);

  var scene   = new THREE.Scene();
  var camera  = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

  // uniforms
  var dbSize = new THREE.Vector2(1,1); // drawing-buffer size
  var uniforms = {
    resolution: { value: dbSize.clone() },
    time:       { value: 0.0 },
    xScale:     { value: 1.0 },
    yScale:     { value: 0.55 },
    distortion: { value: 0.050 }
  };

  // shaders (precision fallback + divide-by-zero guards)
  var vs = 'attribute vec3 position; void main(){ gl_Position = vec4(position,1.0); }';
  var fs = [
    '#ifdef GL_FRAGMENT_PRECISION_HIGH',
    'precision highp float;',
    '#else',
    'precision mediump float;',
    '#endif',
    'uniform vec2  resolution; uniform float time;',
    'uniform float xScale; uniform float yScale; uniform float distortion;',
    'void main(){',
    '  vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);',
    '  float d = length(p) * distortion;',
    '  float rx = p.x * (1.0 + d);',
    '  float gx = p.x;',
    '  float bx = p.x * (1.0 - d);',
    '  float dr = abs(p.y + sin((rx + time) * xScale) * yScale);',
    '  float dg = abs(p.y + sin((gx + time) * xScale) * yScale);',
    '  float db = abs(p.y + sin((bx + time) * xScale) * yScale);',
    '  dr = max(dr, 1e-4); dg = max(dg, 1e-4); db = max(db, 1e-4);',
    '  float r = 0.05 / dr;',
    '  float g = 0.05 / dg;',
    '  float b = 0.05 / db;',
    '  gl_FragColor = vec4(r, g, b, 1.0);',
    '}'
  ].join('');

  // fullscreen two-triangle quad
  var geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
    -1,-1,0,  1,-1,0, -1, 1,0,
     1,-1,0, -1, 1,0,  1, 1,0
  ]), 3));

  var material = new THREE.RawShaderMaterial({
    vertexShader: vs,
    fragmentShader: fs,
    uniforms: uniforms,
    transparent: true
  });

  var mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  function resize() {
    // Size the canvas to the banner container in CSS pixels
    var w = container.clientWidth  || window.innerWidth  || 1;
    var h = container.clientHeight || Math.round(window.innerHeight * 0.6) || 1;

    // Tell Three to match CSS size; its internal drawing buffer = CSS * DPR
    renderer.setSize(w, h, false);

    // Get the actual drawing-buffer size (in physical pixels) and pass it to the shader
    if (renderer.getDrawingBufferSize) {
      renderer.getDrawingBufferSize(dbSize);
      uniforms.resolution.value.copy(dbSize);
    } else {
      // Fallback if API not present (very old Three): approximate
      uniforms.resolution.value.set(Math.floor(w * dpr), Math.floor(h * dpr));
    }
  }

  resize();
  if ('ResizeObserver' in window) {
    try { new ResizeObserver(resize).observe(container); }
    catch(e){ window.addEventListener('resize', resize); }
  } else {
    window.addEventListener('resize', resize);
  }

  // Animation loop
  var clock = new THREE.Clock();
  (function raf(){
    uniforms.time.value += clock.getDelta();
    renderer.render(scene, camera);
    requestAnimationFrame(raf);
  })();

  // Handle rare context loss (prevents a permanent black canvas)
  canvas.addEventListener('webglcontextlost', function(e){ e.preventDefault(); }, false);
  canvas.addEventListener('webglcontextrestored', function(){
    resize();
  }, false);
})();
</script>
