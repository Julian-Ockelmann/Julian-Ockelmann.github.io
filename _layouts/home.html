<script>
(function () {
  // Prevent double-boot
  if (window.__homeShaderBooted) return;
  window.__homeShaderBooted = true;

  var container = document.getElementById('shader-banner');
  var canvas    = document.getElementById('webgl-canvas');
  if (!container || !canvas || typeof THREE === 'undefined') return;

  // Renderer
  var renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
  var dpr = Math.min(window.devicePixelRatio || 1, 2);
  renderer.setPixelRatio(dpr);

  // Scene + camera
  var scene  = new THREE.Scene();
  var camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

  // Uniforms (resolution must be drawing-buffer size)
  var dbSize = new THREE.Vector2(1,1);
  var uniforms = {
    resolution: { value: dbSize.clone() },
    time:       { value: 0.0 },
    xScale:     { value: 1.0 },
    yScale:     { value: 0.55 },
    distortion: { value: 0.050 }
  };

  // Shaders (precision-safe + tiny-divisor guards)
  var vs = 'attribute vec3 position; void main(){ gl_Position = vec4(position,1.0); }';
  var fs = [
    '#ifdef GL_FRAGMENT_PRECISION_HIGH',
    'precision highp float;',
    '#else',
    'precision mediump float;',
    '#endif',
    'uniform vec2  resolution; uniform float time;',
    'uniform float xScale; uniform float yScale; uniform float distortion;',
    'void main(){',
    '  vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);',
    '  float d = length(p) * distortion;',
    '  float rx = p.x * (1.0 + d);',
    '  float gx = p.x;',
    '  float bx = p.x * (1.0 - d);',
    '  float dr = abs(p.y + sin((rx + time) * xScale) * yScale);',
    '  float dg = abs(p.y + sin((gx + time) * xScale) * yScale);',
    '  float db = abs(p.y + sin((bx + time) * xScale) * yScale);',
    '  dr = max(dr, 1e-4); dg = max(dg, 1e-4); db = max(db, 1e-4);',
    '  gl_FragColor = vec4(0.05/dr, 0.05/dg, 0.05/db, 1.0);',
    '}'
  ].join('');

  // âœ… Fullscreen *single* triangle (no diagonal seam)
  // Covers NDC square by overshooting to (3,-1) and (-1,3)
  var positions = new Float32Array([
    -1, -1, 0,
     3, -1, 0,
    -1,  3, 0
  ]);
  var geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  var material = new THREE.RawShaderMaterial({
    vertexShader: vs,
    fragmentShader: fs,
    uniforms: uniforms,
    depthTest: false,
    depthWrite: false,
    side: THREE.FrontSide,
    transparent: true
  });

  var mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  function resize() {
    // CSS size from container
    var w = container.clientWidth  || window.innerWidth  || 1;
    var h = container.clientHeight || Math.round(window.innerHeight * 0.6) || 1;

    // Match CSS size; internal drawing buffer = CSS * DPR
    renderer.setSize(w, h, false);

    // Pass actual drawing-buffer size to shader (avoids diagonal split)
    if (renderer.getDrawingBufferSize) {
      renderer.getDrawingBufferSize(dbSize);
      uniforms.resolution.value.copy(dbSize);
    } else {
      uniforms.resolution.value.set(Math.floor(w * dpr), Math.floor(h * dpr));
    }
  }

  // Initial + subsequent resizes (orientation, URL bar show/hide, etc.)
  var ro;
  try { ro = new ResizeObserver(resize); ro.observe(container); } catch(e) {}
  window.addEventListener('resize', resize, { passive: true });
  window.addEventListener('orientationchange', resize, { passive: true });
  document.addEventListener('visibilitychange', function(){ if (!document.hidden) resize(); });

  resize();

  // RAF loop
  var last = performance.now();
  (function raf(now){
    var dt = Math.min((now - last) / 1000, 0.1); // clamp
    last = now;
    uniforms.time.value += dt;
    renderer.render(scene, camera);
    requestAnimationFrame(raf);
  })(last);

  // Context loss safety
  canvas.addEventListener('webglcontextlost', function(e){ e.preventDefault(); }, false);
  canvas.addEventListener('webglcontextrestored', function(){ resize(); }, false);
})();
</script>
